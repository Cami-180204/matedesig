<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8"/>
<title>Graficador de desigualdades (offline ligero)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  canvas {background: #fff; border: 1px solid #000; border-radius: 8px; cursor: grab; touch-action: none;}
  canvas:active {cursor: grabbing;}
  .btn {background: #4b5563; color: #fff; font-weight: 600; border-radius: 6px; padding: 6px 12px;}
  .mv {width: 34px; height: 34px; display: flex; align-items: center; justify-content: center;}
</style>
</head>
<body class="bg-gray-100 p-6 flex flex-col items-center gap-4">
  <h1 class="text-xl font-bold">Graficador de desigualdades (offline ligero)</h1>
  <div id="inputWrap" class="grid grid-cols-2 gap-4 w-full max-w-4xl"></div>
  <button id="add" class="btn bg-green-600">+ desigualdad</button>
  <div class="flex gap-3 items-center">
    <button id="draw" class="btn bg-blue-600">Graficar</button>
    <button id="zin" class="btn">+</button>
    <button id="zout" class="btn">−</button>
    <div class="grid grid-cols-3 gap-0 select-none">
      <div></div><button class="btn mv" data-d="up">▲</button><div></div>
      <button class="btn mv" data-d="left">◀</button><button class="btn mv" data-d="re">⌖</button><button class="btn mv" data-d="right">▶</button>
      <div></div><button class="btn mv" data-d="down">▼</button><div></div>
    </div>
  </div>
  <canvas id="cv" width="1024" height="640"></canvas>
<script>
const tpl = () => `<div class="flex flex-col gap-1"><input class="ineq px-2 py-1 border rounded" placeholder="4x+2y<=100"/></div>`;
const wrap = document.getElementById('inputWrap');
for (let i = 0; i < 3; i++) wrap.insertAdjacentHTML('beforeend', tpl());
document.getElementById('add').onclick = () => wrap.insertAdjacentHTML('beforeend', tpl());
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
let scale = 40, off = {x: cv.width/2, y: cv.height/2};
const pal = ['#ef4444','#3b82f6','#10b981','#f59e0b','#8b5cf6','#ec4899'];
const tp = (x,y) => ({x:off.x+x*scale,y:off.y-y*scale});
const tc = (px,py) => ({x:(px-off.x)/scale,y:(off.y-py)/scale});
function parse(e) {
  e = e.replaceAll('*','').replaceAll(' ','');
  const ops = ['<=','>=','<','>','='];
  const o = ops.find(op => e.includes(op));
  if (!o) throw `Operador? -> ${e}`;
  const [l,r] = e.split(o);
  const ex = `(${math.parse(l)})-(${math.parse(r)})`;
  const test = (x,y) => {
    const v = Function('x','y',`return ${ex}`)(x,y);
    switch(o){
      case '<=': return v <= 1e-9;
      case '<':  return v < 0;
      case '>=': return v >= -1e-9;
      case '>':  return v > 0;
      default:   return Math.abs(v) < 1e-9;
    }
  };
  return {raw:e,expr:ex,test,color:pal.pop()||'#000'};
}
function grid(){
  ctx.clearRect(0,0,cv.width,cv.height);
  ctx.lineWidth=1; ctx.strokeStyle='#e5e7eb';
  for(let x=off.x%scale;x<cv.width;x+=scale){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,cv.height);ctx.stroke();}
  for(let y=off.y%scale;y<cv.height;y+=scale){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(cv.width,y);ctx.stroke();}
  ctx.strokeStyle='#000';ctx.beginPath();ctx.moveTo(0,off.y);ctx.lineTo(cv.width,off.y);ctx.moveTo(off.x,0);ctx.lineTo(off.x,cv.height);ctx.stroke();
  ctx.font='10px Arial';ctx.fillStyle='#000';
  for(let i=-cv.width/scale;i<cv.width/scale;i++){const p=tp(i,0);if(p.x>0&&p.x<cv.width)ctx.fillText(i,p.x+2,off.y+12);}
  for(let j=-cv.height/scale;j<cv.height/scale;j++){const p=tp(0,j);if(p.y>0&&p.y<cv.height)ctx.fillText(j,p.x+4,p.y-2);}
}
function shade(ins){
  const img=ctx.getImageData(0,0,cv.width,cv.height);
  const d=img.data; const step=4;
  for(let px=0;px<cv.width;px+=step) for(let py=0;py<cv.height;py+=step){
    const {x,y}=tc(px,py);
    if(ins.every(f=>f.test(x,y)))
      for(let dx=0;dx<step;dx++) for(let dy=0;dy<step;dy++){
        const id=((py+dy)*cv.width+px+dx)*4;
        d[id]=255; d[id+1]=255; d[id+2]=150; d[id+3]=90;
      }
  }
  ctx.putImageData(img,0,0);
}
function border(ins){
  ins.forEach((f,i)=>{
    ctx.strokeStyle=f.color; ctx.lineWidth=2; ctx.beginPath();
    let started=false,lx=0,ly=0;
    for(let px=0;px<cv.width;px++){
      let found=false;
      for(let py=0;py<cv.height;py++){
        const {x,y}=tc(px,py);
        if(Math.abs(Function('x','y',`return ${f.expr}`)(x,y))<1e-2){
          if(!started){ctx.moveTo(px,py); started=true;}
          else ctx.lineTo(px,py);
          lx=px; ly=py; found=true; break;
        }
      }
    }
    ctx.stroke(); ctx.fillStyle=f.color; ctx.font='12px Arial';
    ctx.fillText(f.raw,lx+4,ly-4);
  });
}
function verts(ins){
  const vs=[];
  for(let i=0;i<ins.length;i++) for(let j=i+1;j<ins.length;j++){
    try{
      const eq1=ins[i].raw.replace(/<=|>=|<|>/,'='), eq2=ins[j].raw.replace(/<=|>=|<|>/,'=');
      const sol=math.lusolve(
        [[math.derivative(eq1,'x').evaluate({x:1,y:1}),math.derivative(eq1,'y').evaluate({x:1,y:1})],
         [math.derivative(eq2,'x').evaluate({x:1,y:1}),math.derivative(eq2,'y').evaluate({x:1,y:1})]],
        [math.parse(eq1).evaluate({x:0,y:0}),math.parse(eq2).evaluate({x:0,y:0})]).toArray();
      const [x,y]=sol.map(v=>Number(v.toFixed(2)));
      if(ins.every(f=>f.test(x,y))) vs.push({x,y});
    }catch(e){}
  }
  vs.forEach(v=>{
    const p=tp(v.x,v.y); ctx.beginPath(); ctx.fillStyle='#000';
    ctx.arc(p.x,p.y,3,0,2*Math.PI); ctx.fill(); ctx.fillText(`(${v.x},${v.y})`,p.x+4,p.y-4);
  });
}
function plot(){
  try{
    const ins=[...document.querySelectorAll('.ineq')].map(e=>e.value.trim()).filter(Boolean).map(parse);
    grid(); shade(ins); border(ins); verts(ins);
  }catch(e){alert(e);}
}
document.getElementById('draw').onclick=plot;
document.getElementById('zin').onclick=()=>{scale=Math.min(scale+10,120);plot();};
document.getElementById('zout').onclick=()=>{scale=Math.max(scale-10,10);plot();};
document.querySelectorAll('[data-d]').forEach(b=>b.onclick=()=>{
  const s=20;
  switch(b.dataset.d){
    case 'up': off.y += s; break;
    case 'down': off.y -= s; break;
    case 'left': off.x += s; break;
    case 'right': off.x -= s; break;
    default: off = {x:cv.width/2, y:cv.height/2};
  }
  plot();
});
let drag=false, start={x:0,y:0}, o0={x:0,y:0};
cv.onpointerdown=e=>{drag=true;start={x:e.clientX,y:e.clientY};o0={...off};cv.setPointerCapture(e.pointerId);};
cv.onpointermove=e=>{if(!drag)return;off.x=o0.x+(e.clientX-start.x);off.y=o0.y+(e.clientY-start.y);plot();};
cv.onpointerup=()=>drag=false;
cv.onwheel=e=>{e.preventDefault();scale=Math.max(10,Math.min(120,scale+(e.deltaY>0?-10:10)));plot();};
grid();
</script>
</body>
</html>

